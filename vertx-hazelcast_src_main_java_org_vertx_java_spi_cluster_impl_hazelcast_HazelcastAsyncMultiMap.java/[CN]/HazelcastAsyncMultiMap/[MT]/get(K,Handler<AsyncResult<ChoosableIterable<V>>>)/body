{
  ChoosableSet<V> entries=cache.get(k);
  DefaultFutureResult<ChoosableIterable<V>> result=new DefaultFutureResult<>();
  if (entries != null && entries.isInitialised()) {
    result.setResult(entries).setHandler(resultHandler);
  }
 else {
    vertx.executeBlocking(new Action<Collection<V>>(){
      public Collection<V> perform(){
        return map.get(k);
      }
    }
,new AsyncResultHandler<Collection<V>>(){
      public void handle(      AsyncResult<Collection<V>> result){
        DefaultFutureResult<ChoosableIterable<V>> sresult=new DefaultFutureResult<>();
        if (result.succeeded()) {
          Collection<V> entries=result.result();
          ChoosableSet<V> sids;
          if (entries != null) {
            sids=new ChoosableSet<>(entries.size());
            for (            V hid : entries) {
              sids.add(hid);
            }
          }
 else {
            sids=new ChoosableSet<>(0);
          }
          ChoosableSet<V> prev=cache.putIfAbsent(k,sids);
          if (prev != null) {
            prev.merge(sids);
            sids=prev;
          }
          sids.setInitialised();
          sresult.setResult(sids);
        }
 else {
          sresult.setFailure(result.cause());
        }
        sresult.setHandler(resultHandler);
      }
    }
);
  }
}
