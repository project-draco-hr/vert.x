{
  if (requestHandler == null && wsHandler == null) {
    throw new IllegalStateException("Set request or websocket handler first");
  }
  if (listening) {
    throw new IllegalStateException("Listen already called");
  }
  listening=true;
synchronized (vertx.sharedHttpServers()) {
    id=new ServerID(port,host);
    serverOrigin=(isSSL() ? "https" : "http") + "://" + host+ ":"+ port;
    DefaultHttpServer shared=vertx.sharedHttpServers().get(id);
    if (shared == null) {
      serverChannelGroup=new DefaultChannelGroup("vertx-acceptor-channels",GlobalEventExecutor.INSTANCE);
      ServerBootstrap bootstrap=new ServerBootstrap();
      bootstrap.group(availableWorkers);
      bootstrap.channel(NioServerSocketChannel.class);
      tcpHelper.applyConnectionOptions(bootstrap);
      tcpHelper.checkSSL(vertx);
      bootstrap.childHandler(new ChannelInitializer<Channel>(){
        @Override protected void initChannel(        Channel ch) throws Exception {
          ChannelPipeline pipeline=ch.pipeline();
          pipeline.addLast("exceptionDispatcher",EXCEPTION_DISPATCH_HANDLER);
          if (tcpHelper.isSSL()) {
            SSLEngine engine=tcpHelper.getSSLContext().createSSLEngine();
            engine.setUseClientMode(false);
switch (tcpHelper.getClientAuth()) {
case REQUEST:
{
                engine.setWantClientAuth(true);
                break;
              }
case REQUIRED:
{
              engine.setNeedClientAuth(true);
              break;
            }
case NONE:
{
            engine.setNeedClientAuth(false);
            break;
          }
      }
      pipeline.addLast("ssl",new SslHandler(engine));
    }
    pipeline.addLast("flashpolicy",new FlashPolicyHandler());
    pipeline.addLast("httpDecoder",new HttpRequestDecoder());
    pipeline.addLast("httpEncoder",new HttpResponseEncoder());
    if (tcpHelper.isSSL()) {
      pipeline.addLast("chunkedWriter",new ChunkedWriteHandler());
    }
    pipeline.addLast("handler",new ServerHandler());
  }
}
);
addHandlers(this);
try {
  bindFuture=bootstrap.bind(new InetSocketAddress(InetAddress.getByName(host),port));
  Channel serverChannel=bindFuture.channel();
  serverChannelGroup.add(serverChannel);
  bindFuture.addListener(new ChannelFutureListener(){
    @Override public void operationComplete(    ChannelFuture channelFuture) throws Exception {
      if (!channelFuture.isSuccess()) {
        vertx.sharedHttpServers().remove(id);
      }
    }
  }
);
}
 catch (final Throwable t) {
  t.printStackTrace();
  if (listenHandler != null) {
    vertx.runOnContext(new VoidHandler(){
      @Override protected void handle(){
        listenHandler.handle(new DefaultFutureResult<HttpServer>(t));
      }
    }
);
  }
 else {
    actualCtx.reportException(t);
  }
  listening=false;
  return this;
}
vertx.sharedHttpServers().put(id,this);
actualServer=this;
}
 else {
actualServer=shared;
addHandlers(actualServer);
}
actualServer.bindFuture.addListener(new ChannelFutureListener(){
@Override public void operationComplete(final ChannelFuture future) throws Exception {
  if (listenHandler != null) {
    final AsyncResult<HttpServer> res;
    if (future.isSuccess()) {
      res=new DefaultFutureResult<HttpServer>(DefaultHttpServer.this);
    }
 else {
      res=new DefaultFutureResult<>(future.cause());
      listening=false;
    }
    actualCtx.execute(future.channel().eventLoop(),new Runnable(){
      @Override public void run(){
        listenHandler.handle(res);
      }
    }
);
  }
 else   if (!future.isSuccess()) {
    listening=false;
    actualCtx.reportException(future.cause());
  }
}
}
);
}
return this;
}
