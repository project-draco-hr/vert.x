{
  super(eventLoop);
  checkNotNull(channelFactory,"channelFactory");
  this.nameServerAddresses=checkNotNull(nameServerAddresses,"nameServerAddresses");
  this.queryTimeoutMillis=checkPositive(queryTimeoutMillis,"queryTimeoutMillis");
  this.resolvedAddressTypes=checkNonEmpty(resolvedAddressTypes,"resolvedAddressTypes");
  this.recursionDesired=recursionDesired;
  this.maxQueriesPerResolve=checkPositive(maxQueriesPerResolve,"maxQueriesPerResolve");
  this.traceEnabled=traceEnabled;
  this.maxPayloadSize=checkPositive(maxPayloadSize,"maxPayloadSize");
  this.optResourceEnabled=optResourceEnabled;
  this.hostsFileEntriesResolver=checkNotNull(hostsFileEntriesResolver,"hostsFileEntriesResolver");
  this.resolveCache=resolveCache;
  this.searchDomains=checkNotNull(searchDomains,"searchDomains");
  this.ndots=checkPositive(ndots,"ndots");
  Bootstrap b=new Bootstrap();
  b.group(executor());
  b.channelFactory(channelFactory);
  b.option(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION,true);
  final DnsResponseHandler responseHandler=new DnsResponseHandler(executor().<Channel>newPromise());
  b.handler(new ChannelInitializer<DatagramChannel>(){
    @Override protected void initChannel(    DatagramChannel ch) throws Exception {
      ch.pipeline().addLast(DECODER,ENCODER,responseHandler);
    }
  }
);
  channelFuture=responseHandler.channelActivePromise;
  ch=(DatagramChannel)b.register().channel();
  ch.config().setRecvByteBufAllocator(new FixedRecvByteBufAllocator(maxPayloadSize));
  ch.closeFuture().addListener(new ChannelFutureListener(){
    @Override public void operationComplete(    ChannelFuture future) throws Exception {
      resolveCache.clear();
    }
  }
);
}
