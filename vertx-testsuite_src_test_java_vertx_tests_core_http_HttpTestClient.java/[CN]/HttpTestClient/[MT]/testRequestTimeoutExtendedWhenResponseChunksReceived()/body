{
  final long timeout=2000;
  AsyncResultHandler<HttpServer> handler=new AsyncResultHandler<HttpServer>(){
    @Override public void handle(    AsyncResult<HttpServer> ar){
      tu.azzert(ar.succeeded());
      final HttpClientRequest req=getRequest(true,"GET","timeoutTest",new Handler<HttpClientResponse>(){
        public void handle(        HttpClientResponse resp){
          tu.azzert(resp.statusCode() == 200);
          resp.endHandler(new Handler<Void>(){
            public void handle(            Void event){
              tu.testComplete();
            }
          }
);
        }
      }
);
      req.exceptionHandler(new Handler<Throwable>(){
        @Override public void handle(        Throwable t){
          tu.azzert(false,"Should not be called");
        }
      }
);
      req.setTimeout(timeout);
      req.end();
    }
  }
;
  startServer(new Handler<HttpServerRequest>(){
    int numChunks=100;
    int count=0;
    long interval=timeout * 2 / numChunks;
    public void handle(    final HttpServerRequest req){
      req.response().setChunked(true);
      vertx.setPeriodic(interval,new Handler<Long>(){
        @Override public void handle(        Long timerID){
          req.response().write("foo");
          if (++count == numChunks) {
            req.response().end();
            vertx.cancelTimer(timerID);
          }
        }
      }
);
    }
  }
,handler);
}
