{
  checkStarted();
  DefaultContext context=vertx.getOrCreateContext();
  if (timeout == -1) {
    timeout=defaultReplyTimeout;
  }
  try {
    message.sender=serverID;
    if (replyHandler != null) {
      message.replyAddress=UUID.randomUUID().toString();
      long timeoutID;
      if (timeout != -1) {
        timeoutID=vertx.setTimer(timeout,new Handler<Long>(){
          @Override public void handle(          Long timerID){
            log.warn("Message reply handler timed out as no reply was received - it will be removed");
            unregisterHandler(message.replyAddress,replyHandler);
            if (asyncResultHandler != null) {
              asyncResultHandler.handle(new DefaultFutureResult<Message<T>>(new ReplyException(ReplyFailure.TIMEOUT,"Timed out waiting for reply")));
            }
          }
        }
);
      }
 else {
        timeoutID=-1;
      }
      registerHandler(message.replyAddress,replyHandler,null,true,true,timeoutID);
    }
    if (replyDest != null) {
      if (!replyDest.equals(this.serverID)) {
        sendRemote(replyDest,message);
      }
 else {
        receiveMessage(message,asyncResultHandler);
      }
    }
 else {
      if (subs != null) {
        subs.get(message.address,new AsyncResultHandler<ChoosableIterable<ServerID>>(){
          public void handle(          AsyncResult<ChoosableIterable<ServerID>> event){
            if (event.succeeded()) {
              ChoosableIterable<ServerID> serverIDs=event.result();
              if (serverIDs != null && !serverIDs.isEmpty()) {
                sendToSubs(serverIDs,message,asyncResultHandler);
              }
 else {
                receiveMessage(message,asyncResultHandler);
              }
            }
 else {
              log.error("Failed to send message",event.cause());
            }
          }
        }
);
      }
 else {
        receiveMessage(message,asyncResultHandler);
      }
    }
  }
  finally {
    if (context != null) {
      vertx.setContext(context);
    }
  }
}
