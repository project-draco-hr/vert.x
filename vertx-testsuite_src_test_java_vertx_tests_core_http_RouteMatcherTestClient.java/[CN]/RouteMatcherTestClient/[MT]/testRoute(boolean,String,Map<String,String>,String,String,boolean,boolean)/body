{
  RouteMatcher matcher=new RouteMatcher();
  Handler<HttpServerRequest> handler=new Handler<HttpServerRequest>(){
    public void handle(    HttpServerRequest req){
      assert(req.params().size() == params.size());
      for (      Map.Entry<String,String> entry : params.entrySet()) {
        assert(entry.getValue().equals(req.params().get(entry.getKey())));
      }
      req.response().end();
    }
  }
;
switch (method) {
case "GET":
    if (regex) {
      matcher.getWithRegEx(pattern,handler);
    }
 else {
      matcher.get(pattern,handler);
    }
  break;
case "PUT":
if (regex) {
  matcher.putWithRegEx(pattern,handler);
}
 else {
  matcher.put(pattern,handler);
}
break;
case "POST":
if (regex) {
matcher.postWithRegEx(pattern,handler);
}
 else {
matcher.post(pattern,handler);
}
break;
case "DELETE":
if (regex) {
matcher.deleteWithRegEx(pattern,handler);
}
 else {
matcher.delete(pattern,handler);
}
break;
case "OPTIONS":
if (regex) {
matcher.optionsWithRegEx(pattern,handler);
}
 else {
matcher.options(pattern,handler);
}
break;
case "HEAD":
if (regex) {
matcher.headWithRegEx(pattern,handler);
}
 else {
matcher.head(pattern,handler);
}
break;
case "TRACE":
if (regex) {
matcher.traceWithRegEx(pattern,handler);
}
 else {
matcher.trace(pattern,handler);
}
break;
case "PATCH":
if (regex) {
matcher.patchWithRegEx(pattern,handler);
}
 else {
matcher.patch(pattern,handler);
}
break;
case "CONNECT":
if (regex) {
matcher.connectWithRegEx(pattern,handler);
}
 else {
matcher.connect(pattern,handler);
}
break;
}
final String noMatchResponseBody="oranges";
if (noMatchHandler) {
matcher.noMatch(new Handler<HttpServerRequest>(){
public void handle(HttpServerRequest req){
req.response().end(noMatchResponseBody);
}
}
);
}
final HttpServer server=vertx.createHttpServer();
server.requestHandler(matcher);
server.listen(8080,"localhost",new AsyncResultHandler<HttpServer>(){
@Override public void handle(AsyncResult<HttpServer> ar){
tu.azzert(ar.succeeded());
final HttpClient client=vertx.createHttpClient().setPort(8080).setHost("localhost");
Handler<HttpClientResponse> respHandler=new Handler<HttpClientResponse>(){
public void handle(HttpClientResponse resp){
if (shouldPass) {
tu.azzert(200 == resp.statusCode());
closeClientAndServer(client,server);
}
 else if (noMatchHandler) {
tu.azzert(200 == resp.statusCode());
resp.bodyHandler(new Handler<Buffer>(){
public void handle(Buffer body){
tu.azzert(noMatchResponseBody.equals(body.toString()));
closeClientAndServer(client,server);
}
}
);
}
 else {
tu.azzert(404 == resp.statusCode());
closeClientAndServer(client,server);
}
}
}
;
final HttpClientRequest req;
switch (method) {
case "GET":
req=client.get(uri,respHandler);
break;
case "PUT":
req=client.put(uri,respHandler);
break;
case "POST":
req=client.post(uri,respHandler);
break;
case "DELETE":
req=client.delete(uri,respHandler);
break;
case "OPTIONS":
req=client.options(uri,respHandler);
break;
case "HEAD":
req=client.head(uri,respHandler);
break;
case "TRACE":
req=client.trace(uri,respHandler);
break;
case "PATCH":
req=client.patch(uri,respHandler);
break;
case "CONNECT":
req=client.connect(uri,respHandler);
break;
default :
throw new IllegalArgumentException("Invalid method:" + method);
}
req.end();
}
}
);
}
