{
  if (headWritten) {
    throw new IllegalStateException("Head already written");
  }
  checkWritten();
  File file=new File(PathAdjuster.adjust(vertx,filename));
  if (!file.exists()) {
    if (notFoundResource != null) {
      setStatusCode(HttpResponseStatus.NOT_FOUND.code());
      sendFile(notFoundResource,(String)null,resultHandler);
    }
 else {
      sendNotFound();
    }
  }
 else {
    if (!contentLengthSet()) {
      putHeader("Content-Length",String.valueOf(file.length()));
    }
    if (!contentTypeSet()) {
      int li=filename.lastIndexOf('.');
      if (li != -1 && li != filename.length() - 1) {
        String ext=filename.substring(li + 1,filename.length());
        String contentType=MimeMapping.getMimeTypeForExtension(ext);
        if (contentType != null) {
          putHeader("Content-Type",contentType);
        }
      }
    }
    prepareHeaders();
    conn.queueForWrite(response);
    conn.sendFile(file);
    channelFuture=conn.write(LastHttpContent.EMPTY_LAST_CONTENT);
    headWritten=written=true;
    if (resultHandler != null) {
      channelFuture.addListener(new ChannelFutureListener(){
        public void operationComplete(        ChannelFuture future) throws Exception {
          final AsyncResult<Void> res;
          if (future.isSuccess()) {
            res=new DefaultFutureResult<>((Void)null);
          }
 else {
            res=new DefaultFutureResult<>(future.cause());
          }
          vertx.runOnContext(new Handler<Void>(){
            @Override public void handle(            Void v){
              resultHandler.handle(res);
            }
          }
);
        }
      }
);
    }
    if (!keepAlive) {
      closeConnAfterWrite();
    }
    conn.responseComplete();
  }
}
