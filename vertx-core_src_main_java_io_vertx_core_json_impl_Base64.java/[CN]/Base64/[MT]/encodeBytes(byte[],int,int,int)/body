{
  int dontBreakLines=options & Base64.DONT_BREAK_LINES;
  int gzip=options & Base64.GZIP;
  if (gzip == Base64.GZIP) {
    java.io.ByteArrayOutputStream baos=null;
    java.util.zip.GZIPOutputStream gzos=null;
    Base64.OutputStream b64os=null;
    try {
      baos=new java.io.ByteArrayOutputStream();
      b64os=new Base64.OutputStream(baos,Base64.ENCODE | options);
      gzos=new java.util.zip.GZIPOutputStream(b64os);
      gzos.write(source,off,len);
      gzos.close();
    }
 catch (    java.io.IOException e) {
      e.printStackTrace();
      return null;
    }
 finally {
      try {
        gzos.close();
      }
 catch (      Exception e) {
      }
      try {
        b64os.close();
      }
 catch (      Exception e) {
      }
      try {
        baos.close();
      }
 catch (      Exception e) {
      }
    }
    try {
      return new String(baos.toByteArray(),Base64.PREFERRED_ENCODING);
    }
 catch (    java.io.UnsupportedEncodingException uue) {
      return new String(baos.toByteArray());
    }
  }
 else {
    boolean breakLines=dontBreakLines == 0;
    int len43=len * 4 / 3;
    byte[] outBuff=new byte[len43 + (len % 3 > 0 ? 4 : 0) + (breakLines ? len43 / Base64.MAX_LINE_LENGTH : 0)];
    int d=0;
    int e=0;
    int len2=len - 2;
    int lineLength=0;
    for (; d < len2; d+=3, e+=4) {
      Base64.encode3to4(source,d + off,3,outBuff,e,options);
      lineLength+=4;
      if (breakLines && lineLength == Base64.MAX_LINE_LENGTH) {
        outBuff[e + 4]=Base64.NEW_LINE;
        e++;
        lineLength=0;
      }
    }
    if (d < len) {
      Base64.encode3to4(source,d + off,len - d,outBuff,e,options);
      e+=4;
    }
    try {
      return new String(outBuff,0,e,Base64.PREFERRED_ENCODING);
    }
 catch (    java.io.UnsupportedEncodingException uue) {
      return new String(outBuff,0,e);
    }
  }
}
